### 压缩列表
List、Hash 和 Sorted Set 这三种数据类型，都可以使用压缩列表来保存数据。


zipList 数据结构在内存中的布局，就是一块连续的内存空间，这块空间的起始部分是大小固定的 10 字节元数据，其中记录了 zipList 的总字节数、最后一个元素
的偏移量以及列表元数数量，而这 10 字节后面的内存空间则保存了实际的列表数据。在 zipList 的最后部分，是一个 1 字节的标识（固定 255），用来表示 zipList
的结束。

虽然 ziplist 通过紧凑的内存布局来保存数据，节省了内存空间，但是 ziplist 也面临着随之而来的两个不足：查找复杂度高和潜在的连锁更新风险。

**查找复杂度高**

在 zipList 中头尾元数据的大小固定，并且在 zipList 头部记录了最后一个元素的位置，所以，当在 zipList 中查找第一个或者最后一个元素时，可以很快找到。

但是当要查找中间元素的时候，zipList 就的从头到尾遍历。当 zipList 中保存了很多元素时，查找数据的时间复杂度就增加了。更坏的情况是，当 zipList 中保存的
是字符串时，在查找某个元素的时候，还需要逐一判断元素的每个字符，这样又进一步增加的复杂度。

因此，在使用 zipList 保存 Hash 或 Sorted Set 数据时，都会在 redis.conf 文件中，通过 hash-max-ziplist-entries 和 zset-max-ziplist-entries 
两个参数，来控制保存在 ziplist 中的元素个数。

**连锁更新**

在 zipList 中使用了一块连续的内存空间来保存数据，所以当插入一个新元素的时候，zipList 就需要计算其所需的空间大小，并申请相应的内存空间。在些操作可以从
zipList 的元素插入函数 __ziplistInsert 中看到。

